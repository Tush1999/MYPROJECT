{"ast":null,"code":"\"use strict\";\n/**\n * Given a function fn that takes a callback as its last argument, returns\n * a new version of the function that takes the callback optionally. If\n * the function is not called with a callback for the last argument, the\n * function will return a promise instead.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\n\nfunction callbackToPromise(fn, context, callbackArgIndex) {\n  if (callbackArgIndex === void 0) {\n    callbackArgIndex = void 0;\n  }\n  /* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\n\n\n  return function () {\n    var callArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      callArgs[_i] = arguments[_i];\n    }\n\n    var thisCallbackArgIndex;\n\n    if (callbackArgIndex === void 0) {\n      // istanbul ignore next\n      thisCallbackArgIndex = callArgs.length > 0 ? callArgs.length - 1 : 0;\n    } else {\n      thisCallbackArgIndex = callbackArgIndex;\n    }\n\n    var callbackArg = callArgs[thisCallbackArgIndex];\n\n    if (typeof callbackArg === 'function') {\n      fn.apply(context, callArgs);\n      return void 0;\n    } else {\n      var args_1 = []; // If an explicit callbackArgIndex is set, but the function is called\n      // with too few arguments, we want to push undefined onto args so that\n      // our constructed callback ends up at the right index.\n\n      var argLen = Math.max(callArgs.length, thisCallbackArgIndex);\n\n      for (var i = 0; i < argLen; i++) {\n        args_1.push(callArgs[i]);\n      }\n\n      return new Promise(function (resolve, reject) {\n        args_1.push(function (err, result) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n        });\n        fn.apply(context, args_1);\n      });\n    }\n  };\n}\n\nmodule.exports = callbackToPromise;","map":null,"metadata":{},"sourceType":"script"}